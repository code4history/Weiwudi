(function(){"use strict";try{self["workbox:core:6.6.0"]&&_()}catch{}const F=(u,...s)=>{let f=u;return s.length>0&&(f+=` :: ${JSON.stringify(s)}`),f};class P extends Error{constructor(s,f){const i=F(s,f);super(i),this.name=s,this.details=f}}try{self["workbox:routing:6.6.0"]&&_()}catch{}const X="GET",L=u=>u&&typeof u=="object"?u:{handle:u};class S{constructor(s,f,i=X){this.handler=L(f),this.match=s,this.method=i}setCatchHandler(s){this.catchHandler=L(s)}}class U extends S{constructor(s,f,i){const I=({url:b})=>{const A=s.exec(b.href);if(A&&!(b.origin!==location.origin&&A.index!==0))return A.slice(1)};super(I,f,i)}}class W{constructor(){this._routes=new Map,this._defaultHandlerMap=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",(s=>{const{request:f}=s,i=this.handleRequest({request:f,event:s});i&&s.respondWith(i)}))}addCacheListener(){self.addEventListener("message",(s=>{if(s.data&&s.data.type==="CACHE_URLS"){const{payload:f}=s.data,i=Promise.all(f.urlsToCache.map(I=>{typeof I=="string"&&(I=[I]);const b=new Request(...I);return this.handleRequest({request:b,event:s})}));s.waitUntil(i),s.ports&&s.ports[0]&&i.then(()=>s.ports[0].postMessage(!0))}}))}handleRequest({request:s,event:f}){const i=new URL(s.url,location.href);if(!i.protocol.startsWith("http"))return;const I=i.origin===location.origin,{params:b,route:A}=this.findMatchingRoute({event:f,request:s,sameOrigin:I,url:i});let g=A&&A.handler;const D=s.method;if(!g&&this._defaultHandlerMap.has(D)&&(g=this._defaultHandlerMap.get(D)),!g)return;let R;try{R=g.handle({url:i,request:s,event:f,params:b})}catch(E){R=Promise.reject(E)}const M=A&&A.catchHandler;return R instanceof Promise&&(this._catchHandler||M)&&(R=R.catch(async E=>{if(M)try{return await M.handle({url:i,request:s,event:f,params:b})}catch(B){B instanceof Error&&(E=B)}if(this._catchHandler)return this._catchHandler.handle({url:i,request:s,event:f});throw E})),R}findMatchingRoute({url:s,sameOrigin:f,request:i,event:I}){const b=this._routes.get(i.method)||[];for(const A of b){let g;const D=A.match({url:s,sameOrigin:f,request:i,event:I});if(D)return g=D,(Array.isArray(g)&&g.length===0||D.constructor===Object&&Object.keys(D).length===0||typeof D=="boolean")&&(g=void 0),{route:A,params:g}}return{}}setDefaultHandler(s,f=X){this._defaultHandlerMap.set(f,L(s))}setCatchHandler(s){this._catchHandler=L(s)}registerRoute(s){this._routes.has(s.method)||this._routes.set(s.method,[]),this._routes.get(s.method).push(s)}unregisterRoute(s){if(!this._routes.has(s.method))throw new P("unregister-route-but-not-found-with-method",{method:s.method});const f=this._routes.get(s.method).indexOf(s);if(f>-1)this._routes.get(s.method).splice(f,1);else throw new P("unregister-route-route-not-registered")}}let H;const N=()=>(H||(H=new W,H.addFetchListener(),H.addCacheListener()),H);function O(u,s,f){let i;if(typeof u=="string"){const b=new URL(u,location.href),A=({url:g})=>g.href===b.href;i=new S(A,s,f)}else if(u instanceof RegExp)i=new U(u,s,f);else if(typeof u=="function")i=new S(u,s,f);else if(u instanceof S)i=u;else throw new P("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});return N().registerRoute(i),i}function z(u){const s=20037508342789244e-9,f={};let i;const I=(m,t,h,r)=>m.replace("{z}",t).replace("{x}",h).replace("{y}",r).replace("{-y}",Math.pow(2,t)-r-1),b=(m,t="",h=512)=>{const r=atob(m),e=[];for(let c=0;c<r.length;c+=h){const a=r.slice(c,c+h),n=new Array(a.length);for(let d=0;d<a.length;d++)n[d]=a.charCodeAt(d);const o=new Uint8Array(n);e.push(o)}return new Blob(e,{type:t})},A=async(m,t,h)=>new Promise((r,e)=>{try{if(f[m])r(f[m]);else{const l=indexedDB.open(m);l.onupgradeneeded=function(c){c.target.result.createObjectStore(t,{keyPath:h})},l.onsuccess=function(c){const a=c.target.result;f[m]=a,r(a)},l.onerror=function(c){e(c)}}}catch(l){e(l)}}),g=async m=>(f[m]&&(f[m].close(),delete f[m]),new Promise((t,h)=>{try{const r=indexedDB.deleteDatabase(m);r.onsuccess=async e=>{t()},r.onerror=function(e){h(e)}}catch(r){h(r)}})),D=async(m,t)=>new Promise((h,r)=>{const e=m.transaction([t],"readwrite"),c=e.objectStore(t).clear();c.onsuccess=function(a){},c.onerror=function(a){r(a)},e.oncomplete=function(a){h()},e.onabort=function(a){r(a)},e.onerror=function(a){r(a)}}),R=async(m,t)=>new Promise((h,r)=>{const e=m.transaction([t],"readonly"),c=e.objectStore(t).openCursor();let a=0,n=0;c.onsuccess=function(o){const d=c.result;d&&(a++,n=n+d.value.blob.size,d.continue())},c.onerror=function(o){r(o)},e.oncomplete=function(o){h({count:a,size:n})},e.onabort=function(o){r(o)},e.onerror=function(o){r(o)}}),M=async(m,t,h,r)=>new Promise((e,l)=>{const c=m.transaction([t],"readonly"),a=c.objectStore(t),n=r?a.getKey(h):a.get(h);n.onsuccess=function(o){},n.onerror=function(o){l(o)},c.oncomplete=function(o){e(n.result)},c.onabort=function(o){l(o)},c.onerror=function(o){l(o)}}),E=async(m,t,h)=>new Promise((r,e)=>{const l=m.transaction([t],"readwrite"),a=l.objectStore(t).put(h);a.onsuccess=function(n){},a.onerror=function(n){e(n)},l.oncomplete=function(n){r()},l.onabort=function(n){e(n)},l.onerror=function(n){e(n)}}),B=async(m,t,h)=>new Promise((r,e)=>{const l=m.transaction([t],"readwrite"),a=l.objectStore(t).delete(h);a.onsuccess=function(n){},a.onerror=function(n){e(n)},l.oncomplete=function(n){r()},l.onabort=function(n){e(n)},l.onerror=function(n){e(n)}}),J=async(m,t)=>new Promise((h,r)=>{const e=m.transaction([t],"readwrite"),c=e.objectStore(t).getAllKeys();c.onsuccess=function(a){},c.onerror=function(a){r(a)},e.oncomplete=function(a){h(c.result)},e.onabort=function(a){r(a)},e.onerror=function(a){r(a)}}),K=async({url:m,request:t,event:h,params:r})=>{const e=h.clientId?await self.clients.get(h.clientId):void 0,l=m.pathname.match(/^\/api\/([\w\d]+)(?:\/(.+))?$/);if(l){const c=[...m.searchParams.entries()].reduce((d,p)=>{const x=m.searchParams.getAll(p[0]);return x.length===1?d[p[0]]=x[0]:d[p[0]]=x,d},{}),a=l[1],n=l[2];let o=await G(a,c,n,e);if(o)return o instanceof Response||(o=new Response(o)),o}},Y=async(m,t,h,r,e)=>{let l;const c=await A("Weiwudi"),a=await M(c,"mapSetting",m);if(!e){if(!a)return`Error: MapID "${m}" not found`;if(t<a.minZoom||t>a.maxZoom)l="zoom";else{const x=Math.floor(a.minX/Math.pow(2,a.maxZoom-t)),w=Math.floor(a.maxX/Math.pow(2,a.maxZoom-t)),$=Math.floor(a.minY/Math.pow(2,a.maxZoom-t)),T=Math.floor(a.maxY/Math.pow(2,a.maxZoom-t));(h<x||h>w||r<$||r>T)&&(l="extent")}}let n={},o,d=200,p="OK";if(l)l==="zoom"?(d=404,p="Not Found"):(n={"content-type":"image/png"},o=b("iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAAB3RJTUUH3QgIBToaSbAjlwAAABd0RVh0U29mdHdhcmUAR0xEUE5HIHZlciAzLjRxhaThAAAACHRwTkdHTEQzAAAAAEqAKR8AAAAEZ0FNQQAAsY8L/GEFAAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAAFRJREFUeNrtwQEBAAAAgJD+r+4ICgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgBDwABHHIJwwAAAABJRU5ErkJggg==",n["content-type"]));else{const x=await A(`Weiwudi_${m}`),w=await M(x,"tileCache",`${t}_${h}_${r}`,e),$=new Date().getTime();if(!w||!w.epoch||$-w.epoch>864e5){const T=a.url instanceof Array?a.url[Math.floor(Math.random()*a.url.length)]:a.url,V=I(T,t,h,r);try{const Z=await fetch(V);Z.ok?(n=[...Z.headers.entries()].reduce((k,C)=>({...k,[C[0]]:C[1]}),{}),o=await Z.blob(),await E(x,"tileCache",{z_x_y:`${t}_${h}_${r}`,headers:n,blob:o,epoch:$})):(w?(n=w.headers,o=w.blob):(d=Z.status,p=Z.statusText,n=[...Z.headers.entries()].reduce((k,C)=>({...k,[C[0]]:C[1]}),{}),o=await Z.blob()),i&&i.error++)}catch{w?(n=w.headers,o=w.blob):(d=404,p="Not Found"),i&&i.error++}}else e||(n=w.headers,o=w.blob)}return e?void 0:new Response(o,{status:d,statusText:p,headers:new Headers(n)})},Q=async(m,t)=>{let h=0,r=0;const e=await A(`Weiwudi_${t.mapID}`),l=await J(e,"tileCache");try{const c=[];for(let o=t.minZoom;o<=t.maxZoom;o++){const d=Math.floor(t.maxX/Math.pow(2,t.maxZoom-o)),p=Math.floor(t.minX/Math.pow(2,t.maxZoom-o)),x=Math.floor(t.maxY/Math.pow(2,t.maxZoom-o)),w=Math.floor(t.minY/Math.pow(2,t.maxZoom-o));for(let $=p;$<=d;$++)for(let T=w;T<=x;T++)c.push([o,$,T])}c.length!=t.totalTile&&console.log("Number of tiles is different");let a=c.splice(0,5);for(;a.length;){if(!await self.clients.get(m.id)){i=void 0;return}if(i.cancel){i=void 0,m.postMessage({type:"canceled",message:`Fetching tile of ${t.mapID} is canceled`,mapID:t.mapID});return}const d=a.map(p=>{if(!(l.indexOf(`${p[0]}_${p[1]}_${p[2]}`)>=0))return Y(t.mapID,p[0],p[1],p[2],!0)});await Promise.all(d),h+=d.length,i.count=h,r=Math.floor(h*100/t.totalTile),m.postMessage({type:"proceed",message:`Proceeding the tile fetching: ${t.mapID} ${r}% (${h} / ${t.totalTile})`,percent:r,processed:h,error:i.error,total:t.totalTile,mapID:t.mapID}),a=c.splice(0,5)}const n=i.error;i=void 0,m.postMessage({type:"finish",message:`Fetched all tiles of ${t.mapID}${n?` with ${n} error cases`:""}`,total:t.totalTile,mapID:t.mapID,error:n})}catch(c){i=void 0,m.postMessage({type:"stop",message:`Fetching stopped: ${t.mapID} ${h} / ${t.totalTile}`,reason:c,processed:h,total:t.totalTile,mapID:t.mapID})}},G=async(m,t,h,r)=>{let e;const l=(c,a)=>a.reduce((n,o)=>n||(c[o]===void 0?`Error: Attribute "${o}" is missing`:n),void 0);try{switch(m){case"ping":e="Implemented";break;case"info":if(e=l(t,["mapID"]),!e){const n=await A("Weiwudi","mapSetting","mapID"),o=await M(n,"mapSetting",t.mapID);o?e=new Response(JSON.stringify(o),{headers:new Headers({"content-type":"application/json"})}):e=`Error: MapID "${t.mapID}" not found`}break;case"add":const c=await A("Weiwudi","mapSetting","mapID");if(e=l(t,["mapID","type","url"]),!e)switch(t.tileSize=parseInt(t.tileSize||256),t.type){case"xyz":if(e=l(t,["width","height"]),!e){t.width=parseInt(t.width),t.height=parseInt(t.height);const n=o=>Math.ceil(Math.log(o/t.tileSize)/Math.log(2));t.maxZoom=Math.max(n(t.width),n(t.height)),t.minZoom=t.minZoom?parseInt(t.minZoom):0,t.minX=0,t.minY=0,t.maxX=Math.ceil(t.width/t.tileSize)-1,t.maxY=Math.ceil(t.height/t.tileSize)-1}break;case"wmts":if(!e){const n=d=>6378137*d*Math.PI/180,o=d=>6378137*Math.log(Math.tan(Math.PI/360*(90+d)));if(t.maxZoom&&(t.maxZoom=parseInt(t.maxZoom)),t.minZoom&&(t.minZoom=parseInt(t.minZoom)),t.maxLng&&t.minLng&&t.maxLat&&t.minLat){t.maxLng=parseFloat(t.maxLng),t.minLng=parseFloat(t.minLng),t.maxLat=parseFloat(t.maxLat),t.minLat=parseFloat(t.minLat);const d=n(t.maxLng),p=n(t.minLng),x=o(t.maxLat),w=o(t.minLat);t.minX=Math.floor((s+p)/(2*s)*Math.pow(2,t.maxZoom)),t.maxX=Math.floor((s+d)/(2*s)*Math.pow(2,t.maxZoom)),t.minY=Math.floor((s-x)/(2*s)*Math.pow(2,t.maxZoom)),t.maxY=Math.floor((s-w)/(2*s)*Math.pow(2,t.maxZoom))}}break;default:e='Error: Unknown "type" value'}if(!e){if(!l(t,["maxX","minX","maxY","minY","minZoom","maxZoom"])){t.totalTile=0;const n=(o,d)=>Math.floor(o/Math.pow(2,t.maxZoom-d));for(let o=t.minZoom;o<=t.maxZoom;o++){const d=n(t.minX,o),p=n(t.minY,o),x=n(t.maxX,o),w=n(t.maxY,o);t.totalTile+=(x-d+1)*(w-p+1)}}await E(c,"mapSetting",t),await A(`Weiwudi_${t.mapID}`,"tileCache","z_x_y"),e=new Response(JSON.stringify(t),{headers:new Headers({"content-type":"application/json"})})}break;case"clean":if(e=l(t,["mapID"]),i&&i.mapID==t.mapID)e=`Error: ${t.mapID} is under fetching process. Please cancel it first`;else if(!e){const n=await A(`Weiwudi_${t.mapID}`);await D(n,"tileCache"),e=`Cleaned: ${t.mapID}`}break;case"delete":if(e=l(t,["mapID"]),i&&i.mapID==t.mapID)e=`Error: ${t.mapID} is under fetching process. Please cancel it first`;else if(!e){await g(`Weiwudi_${t.mapID}`);const n=await A("Weiwudi");await B(n,"mapSetting",t.mapID),e=`Deleted: ${t.mapID}`}break;case"cancel":e=l(t,["mapID"]),i&&i.mapID==t.mapID?(i.cancel=!0,e=`Fetching process of ${i.mapID} is canceled`):e=`Error: There are no fetching process of ${t.mapID}`;case"stats":if(e=l(t,["mapID"]),!e){const n=await A("Weiwudi"),o=await M(n,"mapSetting",t.mapID);if(!o)e=`Error: MapID "${t.mapID}" not found`;else{const d=await A(`Weiwudi_${t.mapID}`),p=await R(d,"tileCache");o.totalTile&&(p.total=o.totalTile,p.percent=Math.floor(p.count/p.total*100)),e=new Response(JSON.stringify(p),{headers:new Headers({"content-type":"application/json"})})}}break;case"cache":const a=h.match(/^([^\/]+)\/(\d+)\/(\d+)\/(\d+)$/);a?e=await Y(a[1],parseInt(a[2]),parseInt(a[3]),parseInt(a[4])):e='Error: "cache" api needs mapID, zoom, x, y settings';break;case"fetchAll":if(e=l(t,["mapID"]),!e){const n=await A("Weiwudi"),o=await M(n,"mapSetting",t.mapID);o?o.totalTile?i?e=`Error: Another fetching process is running: "${i.mapID}" (${i.count} / ${i.total})`:(setTimeout(()=>{i={mapID:t.mapID,total:o.totalTile,count:0,error:0},Q(r,o)},1),e=`Fetching task start: ${t.mapID}`):e=`Error: Map "${t.mapID}" cannot fetch all tiles`:e=`Error: MapID "${t.mapID}" not found`}break;default:e=`Error: API ${m} not found`}}catch(c){e=`Error: ${c}`}if(e)return e};u(/^https?:\/\/weiwudi.example.com/,K,"GET")}z(O)})();
//# sourceMappingURL=weiwudi-sw.js.map
