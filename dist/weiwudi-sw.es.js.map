{"version":3,"file":"weiwudi-sw.es.js","sources":["../node_modules/.pnpm/workbox-core@7.4.0/node_modules/workbox-core/_version.js","../node_modules/.pnpm/workbox-core@7.4.0/node_modules/workbox-core/models/messages/messageGenerator.js","../node_modules/.pnpm/workbox-core@7.4.0/node_modules/workbox-core/_private/WorkboxError.js","../node_modules/.pnpm/workbox-routing@7.4.0/node_modules/workbox-routing/_version.js","../node_modules/.pnpm/workbox-routing@7.4.0/node_modules/workbox-routing/utils/constants.js","../node_modules/.pnpm/workbox-routing@7.4.0/node_modules/workbox-routing/utils/normalizeHandler.js","../node_modules/.pnpm/workbox-routing@7.4.0/node_modules/workbox-routing/Route.js","../node_modules/.pnpm/workbox-routing@7.4.0/node_modules/workbox-routing/RegExpRoute.js","../node_modules/.pnpm/workbox-routing@7.4.0/node_modules/workbox-routing/Router.js","../node_modules/.pnpm/workbox-routing@7.4.0/node_modules/workbox-routing/utils/getOrCreateDefaultRouter.js","../node_modules/.pnpm/workbox-routing@7.4.0/node_modules/workbox-routing/registerRoute.js","../src/weiwudi_gw_logic.ts","../src/weiwudi_gw.ts"],"sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:core:7.3.0'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { messages } from './messages.js';\nimport '../../_version.js';\nconst fallback = (code, ...args) => {\n    let msg = code;\n    if (args.length > 0) {\n        msg += ` :: ${JSON.stringify(args)}`;\n    }\n    return msg;\n};\nconst generatorFunction = (code, details = {}) => {\n    const message = messages[code];\n    if (!message) {\n        throw new Error(`Unable to find message for code '${code}'.`);\n    }\n    return message(details);\n};\nexport const messageGenerator = process.env.NODE_ENV === 'production' ? fallback : generatorFunction;\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { messageGenerator } from '../models/messages/messageGenerator.js';\nimport '../_version.js';\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n    /**\n     *\n     * @param {string} errorCode The error code that\n     * identifies this particular error.\n     * @param {Object=} details Any relevant arguments\n     * that will help developers identify issues should\n     * be added as a key on the context object.\n     */\n    constructor(errorCode, details) {\n        const message = messageGenerator(errorCode, details);\n        super(message);\n        this.name = errorCode;\n        this.details = details;\n    }\n}\nexport { WorkboxError };\n","\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:routing:7.3.0'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * The default HTTP method, 'GET', used when there's no specific method\n * configured for a route.\n *\n * @type {string}\n *\n * @private\n */\nexport const defaultMethod = 'GET';\n/**\n * The list of valid HTTP methods associated with requests that could be routed.\n *\n * @type {Array<string>}\n *\n * @private\n */\nexport const validMethods = [\n    'DELETE',\n    'GET',\n    'HEAD',\n    'PATCH',\n    'POST',\n    'PUT',\n];\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport '../_version.js';\n/**\n * @param {function()|Object} handler Either a function, or an object with a\n * 'handle' method.\n * @return {Object} An object with a handle method.\n *\n * @private\n */\nexport const normalizeHandler = (handler) => {\n    if (handler && typeof handler === 'object') {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.hasMethod(handler, 'handle', {\n                moduleName: 'workbox-routing',\n                className: 'Route',\n                funcName: 'constructor',\n                paramName: 'handler',\n            });\n        }\n        return handler;\n    }\n    else {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(handler, 'function', {\n                moduleName: 'workbox-routing',\n                className: 'Route',\n                funcName: 'constructor',\n                paramName: 'handler',\n            });\n        }\n        return { handle: handler };\n    }\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { defaultMethod, validMethods } from './utils/constants.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport './_version.js';\n/**\n * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n * The \"match\" callback determine if a route should be used to \"handle\" a\n * request by returning a non-falsy value if it can. The \"handler\" callback\n * is called when there is a match and should return a Promise that resolves\n * to a `Response`.\n *\n * @memberof workbox-routing\n */\nclass Route {\n    /**\n     * Constructor for Route class.\n     *\n     * @param {workbox-routing~matchCallback} match\n     * A callback function that determines whether the route matches a given\n     * `fetch` event by returning a non-falsy value.\n     * @param {workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resolving to a Response.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     */\n    constructor(match, handler, method = defaultMethod) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(match, 'function', {\n                moduleName: 'workbox-routing',\n                className: 'Route',\n                funcName: 'constructor',\n                paramName: 'match',\n            });\n            if (method) {\n                assert.isOneOf(method, validMethods, { paramName: 'method' });\n            }\n        }\n        // These values are referenced directly by Router so cannot be\n        // altered by minificaton.\n        this.handler = normalizeHandler(handler);\n        this.match = match;\n        this.method = method;\n    }\n    /**\n     *\n     * @param {workbox-routing-handlerCallback} handler A callback\n     * function that returns a Promise resolving to a Response\n     */\n    setCatchHandler(handler) {\n        this.catchHandler = normalizeHandler(handler);\n    }\n}\nexport { Route };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { Route } from './Route.js';\nimport './_version.js';\n/**\n * RegExpRoute makes it easy to create a regular expression based\n * {@link workbox-routing.Route}.\n *\n * For same-origin requests the RegExp only needs to match part of the URL. For\n * requests against third-party servers, you must define a RegExp that matches\n * the start of the URL.\n *\n * @memberof workbox-routing\n * @extends workbox-routing.Route\n */\nclass RegExpRoute extends Route {\n    /**\n     * If the regular expression contains\n     * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n     * the captured values will be passed to the\n     * {@link workbox-routing~handlerCallback} `params`\n     * argument.\n     *\n     * @param {RegExp} regExp The regular expression to match against URLs.\n     * @param {workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     */\n    constructor(regExp, handler, method) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(regExp, RegExp, {\n                moduleName: 'workbox-routing',\n                className: 'RegExpRoute',\n                funcName: 'constructor',\n                paramName: 'pattern',\n            });\n        }\n        const match = ({ url }) => {\n            const result = regExp.exec(url.href);\n            // Return immediately if there's no match.\n            if (!result) {\n                return;\n            }\n            // Require that the match start at the first character in the URL string\n            // if it's a cross-origin request.\n            // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n            // behind this behavior.\n            if (url.origin !== location.origin && result.index !== 0) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`The regular expression '${regExp.toString()}' only partially matched ` +\n                        `against the cross-origin URL '${url.toString()}'. RegExpRoute's will only ` +\n                        `handle cross-origin requests if they match the entire URL.`);\n                }\n                return;\n            }\n            // If the route matches, but there aren't any capture groups defined, then\n            // this will return [], which is truthy and therefore sufficient to\n            // indicate a match.\n            // If there are capture groups, then it will return their values.\n            return result.slice(1);\n        };\n        super(match, handler, method);\n    }\n}\nexport { RegExpRoute };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { defaultMethod } from './utils/constants.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\n/**\n * The Router can be used to process a `FetchEvent` using one or more\n * {@link workbox-routing.Route}, responding with a `Response` if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox-routing\n */\nclass Router {\n    /**\n     * Initializes a new Router.\n     */\n    constructor() {\n        this._routes = new Map();\n        this._defaultHandlerMap = new Map();\n    }\n    /**\n     * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP\n     * method name ('GET', etc.) to an array of all the corresponding `Route`\n     * instances that are registered.\n     */\n    get routes() {\n        return this._routes;\n    }\n    /**\n     * Adds a fetch event listener to respond to events when a route matches\n     * the event's request.\n     */\n    addFetchListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('fetch', ((event) => {\n            const { request } = event;\n            const responsePromise = this.handleRequest({ request, event });\n            if (responsePromise) {\n                event.respondWith(responsePromise);\n            }\n        }));\n    }\n    /**\n     * Adds a message event listener for URLs to cache from the window.\n     * This is useful to cache resources loaded on the page prior to when the\n     * service worker started controlling it.\n     *\n     * The format of the message data sent from the window should be as follows.\n     * Where the `urlsToCache` array may consist of URL strings or an array of\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n     *\n     * ```\n     * {\n     *   type: 'CACHE_URLS',\n     *   payload: {\n     *     urlsToCache: [\n     *       './script1.js',\n     *       './script2.js',\n     *       ['./script3.js', {mode: 'no-cors'}],\n     *     ],\n     *   },\n     * }\n     * ```\n     */\n    addCacheListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('message', ((event) => {\n            // event.data is type 'any'\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (event.data && event.data.type === 'CACHE_URLS') {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                const { payload } = event.data;\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n                }\n                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\n                    if (typeof entry === 'string') {\n                        entry = [entry];\n                    }\n                    const request = new Request(...entry);\n                    return this.handleRequest({ request, event });\n                    // TODO(philipwalton): TypeScript errors without this typecast for\n                    // some reason (probably a bug). The real type here should work but\n                    // doesn't: `Array<Promise<Response> | undefined>`.\n                })); // TypeScript\n                event.waitUntil(requestPromises);\n                // If a MessageChannel was used, reply to the message on success.\n                if (event.ports && event.ports[0]) {\n                    void requestPromises.then(() => event.ports[0].postMessage(true));\n                }\n            }\n        }));\n    }\n    /**\n     * Apply the routing rules to a FetchEvent object to get a Response from an\n     * appropriate Route's handler.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to handle.\n     * @param {ExtendableEvent} options.event The event that triggered the\n     *     request.\n     * @return {Promise<Response>|undefined} A promise is returned if a\n     *     registered route can handle the request. If there is no matching\n     *     route and there's no `defaultHandler`, `undefined` is returned.\n     */\n    handleRequest({ request, event, }) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'handleRequest',\n                paramName: 'options.request',\n            });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith('http')) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n            }\n            return;\n        }\n        const sameOrigin = url.origin === location.origin;\n        const { params, route } = this.findMatchingRoute({\n            event,\n            request,\n            sameOrigin,\n            url,\n        });\n        let handler = route && route.handler;\n        const debugMessages = [];\n        if (process.env.NODE_ENV !== 'production') {\n            if (handler) {\n                debugMessages.push([`Found a route to handle this request:`, route]);\n                if (params) {\n                    debugMessages.push([\n                        `Passing the following params to the route's handler:`,\n                        params,\n                    ]);\n                }\n            }\n        }\n        // If we don't have a handler because there was no matching route, then\n        // fall back to defaultHandler if that's defined.\n        const method = request.method;\n        if (!handler && this._defaultHandlerMap.has(method)) {\n            if (process.env.NODE_ENV !== 'production') {\n                debugMessages.push(`Failed to find a matching route. Falling ` +\n                    `back to the default handler for ${method}.`);\n            }\n            handler = this._defaultHandlerMap.get(method);\n        }\n        if (!handler) {\n            if (process.env.NODE_ENV !== 'production') {\n                // No handler so Workbox will do nothing. If logs is set of debug\n                // i.e. verbose, we should print out this information.\n                logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n            }\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            // We have a handler, meaning Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n            debugMessages.forEach((msg) => {\n                if (Array.isArray(msg)) {\n                    logger.log(...msg);\n                }\n                else {\n                    logger.log(msg);\n                }\n            });\n            logger.groupEnd();\n        }\n        // Wrap in try and catch in case the handle method throws a synchronous\n        // error. It should still callback to the catch handler.\n        let responsePromise;\n        try {\n            responsePromise = handler.handle({ url, request, event, params });\n        }\n        catch (err) {\n            responsePromise = Promise.reject(err);\n        }\n        // Get route's catch handler, if it exists\n        const catchHandler = route && route.catchHandler;\n        if (responsePromise instanceof Promise &&\n            (this._catchHandler || catchHandler)) {\n            responsePromise = responsePromise.catch(async (err) => {\n                // If there's a route catch handler, process that first\n                if (catchHandler) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // Still include URL here as it will be async from the console group\n                        // and may not make sense without the URL\n                        logger.groupCollapsed(`Error thrown when responding to: ` +\n                            ` ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);\n                        logger.error(`Error thrown by:`, route);\n                        logger.error(err);\n                        logger.groupEnd();\n                    }\n                    try {\n                        return await catchHandler.handle({ url, request, event, params });\n                    }\n                    catch (catchErr) {\n                        if (catchErr instanceof Error) {\n                            err = catchErr;\n                        }\n                    }\n                }\n                if (this._catchHandler) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // Still include URL here as it will be async from the console group\n                        // and may not make sense without the URL\n                        logger.groupCollapsed(`Error thrown when responding to: ` +\n                            ` ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);\n                        logger.error(`Error thrown by:`, route);\n                        logger.error(err);\n                        logger.groupEnd();\n                    }\n                    return this._catchHandler.handle({ url, request, event });\n                }\n                throw err;\n            });\n        }\n        return responsePromise;\n    }\n    /**\n     * Checks a request and URL (and optionally an event) against the list of\n     * registered routes, and if there's a match, returns the corresponding\n     * route along with any params generated by the match.\n     *\n     * @param {Object} options\n     * @param {URL} options.url\n     * @param {boolean} options.sameOrigin The result of comparing `url.origin`\n     *     against the current origin.\n     * @param {Request} options.request The request to match.\n     * @param {Event} options.event The corresponding event.\n     * @return {Object} An object with `route` and `params` properties.\n     *     They are populated if a matching route was found or `undefined`\n     *     otherwise.\n     */\n    findMatchingRoute({ url, sameOrigin, request, event, }) {\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes) {\n            let params;\n            // route.match returns type any, not possible to change right now.\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const matchResult = route.match({ url, sameOrigin, request, event });\n            if (matchResult) {\n                if (process.env.NODE_ENV !== 'production') {\n                    // Warn developers that using an async matchCallback is almost always\n                    // not the right thing to do.\n                    if (matchResult instanceof Promise) {\n                        logger.warn(`While routing ${getFriendlyURL(url)}, an async ` +\n                            `matchCallback function was used. Please convert the ` +\n                            `following route to use a synchronous matchCallback function:`, route);\n                    }\n                }\n                // See https://github.com/GoogleChrome/workbox/issues/2079\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                params = matchResult;\n                if (Array.isArray(params) && params.length === 0) {\n                    // Instead of passing an empty array in as params, use undefined.\n                    params = undefined;\n                }\n                else if (matchResult.constructor === Object && // eslint-disable-line\n                    Object.keys(matchResult).length === 0) {\n                    // Instead of passing an empty object in as params, use undefined.\n                    params = undefined;\n                }\n                else if (typeof matchResult === 'boolean') {\n                    // For the boolean value true (rather than just something truth-y),\n                    // don't set params.\n                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n                    params = undefined;\n                }\n                // Return early if have a match.\n                return { route, params };\n            }\n        }\n        // If no match was found above, return and empty object.\n        return {};\n    }\n    /**\n     * Define a default `handler` that's called when no routes explicitly\n     * match the incoming request.\n     *\n     * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.\n     *\n     * Without a default handler, unmatched requests will go against the\n     * network as if there were no service worker present.\n     *\n     * @param {workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     * @param {string} [method='GET'] The HTTP method to associate with this\n     * default handler. Each method has its own default.\n     */\n    setDefaultHandler(handler, method = defaultMethod) {\n        this._defaultHandlerMap.set(method, normalizeHandler(handler));\n    }\n    /**\n     * If a Route throws an error while handling a request, this `handler`\n     * will be called and given a chance to provide a response.\n     *\n     * @param {workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n    setCatchHandler(handler) {\n        this._catchHandler = normalizeHandler(handler);\n    }\n    /**\n     * Registers a route with the router.\n     *\n     * @param {workbox-routing.Route} route The route to register.\n     */\n    registerRoute(route) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(route, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route, 'match', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.isType(route.handler, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route.handler, 'handle', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.handler',\n            });\n            assert.isType(route.method, 'string', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.method',\n            });\n        }\n        if (!this._routes.has(route.method)) {\n            this._routes.set(route.method, []);\n        }\n        // Give precedence to all of the earlier routes by adding this additional\n        // route to the end of the array.\n        this._routes.get(route.method).push(route);\n    }\n    /**\n     * Unregisters a route with the router.\n     *\n     * @param {workbox-routing.Route} route The route to unregister.\n     */\n    unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n            throw new WorkboxError('unregister-route-but-not-found-with-method', {\n                method: route.method,\n            });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n            this._routes.get(route.method).splice(routeIndex, 1);\n        }\n        else {\n            throw new WorkboxError('unregister-route-route-not-registered');\n        }\n    }\n}\nexport { Router };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { Router } from '../Router.js';\nimport '../_version.js';\nlet defaultRouter;\n/**\n * Creates a new, singleton Router instance if one does not exist. If one\n * does already exist, that instance is returned.\n *\n * @private\n * @return {Router}\n */\nexport const getOrCreateDefaultRouter = () => {\n    if (!defaultRouter) {\n        defaultRouter = new Router();\n        // The helpers that use the default Router assume these listeners exist.\n        defaultRouter.addFetchListener();\n        defaultRouter.addCacheListener();\n    }\n    return defaultRouter;\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Route } from './Route.js';\nimport { RegExpRoute } from './RegExpRoute.js';\nimport { getOrCreateDefaultRouter } from './utils/getOrCreateDefaultRouter.js';\nimport './_version.js';\n/**\n * Easily register a RegExp, string, or function with a caching\n * strategy to a singleton Router instance.\n *\n * This method will generate a Route for you if needed and\n * call {@link workbox-routing.Router#registerRoute}.\n *\n * @param {RegExp|string|workbox-routing.Route~matchCallback|workbox-routing.Route} capture\n * If the capture param is a `Route`, all other arguments will be ignored.\n * @param {workbox-routing~handlerCallback} [handler] A callback\n * function that returns a Promise resulting in a Response. This parameter\n * is required if `capture` is not a `Route` object.\n * @param {string} [method='GET'] The HTTP method to match the Route\n * against.\n * @return {workbox-routing.Route} The generated `Route`.\n *\n * @memberof workbox-routing\n */\nfunction registerRoute(capture, handler, method) {\n    let route;\n    if (typeof capture === 'string') {\n        const captureUrl = new URL(capture, location.href);\n        if (process.env.NODE_ENV !== 'production') {\n            if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n                throw new WorkboxError('invalid-string', {\n                    moduleName: 'workbox-routing',\n                    funcName: 'registerRoute',\n                    paramName: 'capture',\n                });\n            }\n            // We want to check if Express-style wildcards are in the pathname only.\n            // TODO: Remove this log message in v4.\n            const valueToCheck = capture.startsWith('http')\n                ? captureUrl.pathname\n                : capture;\n            // See https://github.com/pillarjs/path-to-regexp#parameters\n            const wildcards = '[*:?+]';\n            if (new RegExp(`${wildcards}`).exec(valueToCheck)) {\n                logger.debug(`The '$capture' parameter contains an Express-style wildcard ` +\n                    `character (${wildcards}). Strings are now always interpreted as ` +\n                    `exact matches; use a RegExp for partial or wildcard matches.`);\n            }\n        }\n        const matchCallback = ({ url }) => {\n            if (process.env.NODE_ENV !== 'production') {\n                if (url.pathname === captureUrl.pathname &&\n                    url.origin !== captureUrl.origin) {\n                    logger.debug(`${capture} only partially matches the cross-origin URL ` +\n                        `${url.toString()}. This route will only handle cross-origin requests ` +\n                        `if they match the entire URL.`);\n                }\n            }\n            return url.href === captureUrl.href;\n        };\n        // If `capture` is a string then `handler` and `method` must be present.\n        route = new Route(matchCallback, handler, method);\n    }\n    else if (capture instanceof RegExp) {\n        // If `capture` is a `RegExp` then `handler` and `method` must be present.\n        route = new RegExpRoute(capture, handler, method);\n    }\n    else if (typeof capture === 'function') {\n        // If `capture` is a function then `handler` and `method` must be present.\n        route = new Route(capture, handler, method);\n    }\n    else if (capture instanceof Route) {\n        route = capture;\n    }\n    else {\n        throw new WorkboxError('unsupported-route-type', {\n            moduleName: 'workbox-routing',\n            funcName: 'registerRoute',\n            paramName: 'capture',\n        });\n    }\n    const defaultRouter = getOrCreateDefaultRouter();\n    defaultRouter.registerRoute(route);\n    return route;\n}\nexport { registerRoute };\n","/// <reference lib=\"webworker\" />\r\nimport { RouteHandlerCallback } from 'workbox-core';\r\n\r\ninterface MapSetting {\r\n  mapID: string;\r\n  type?: string;\r\n  url?: string | string[];\r\n  minZoom?: number;\r\n  maxZoom?: number;\r\n  minX?: number;\r\n  maxX?: number;\r\n  minY?: number;\r\n  maxY?: number;\r\n  totalTile?: number;\r\n  minLat?: number;\r\n  minLng?: number;\r\n  maxLat?: number;\r\n  maxLng?: number;\r\n  width?: number;\r\n  height?: number;\r\n  tileSize?: number;\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  [key: string]: any;\r\n}\r\n\r\ninterface TileCacheItem {\r\n  z_x_y?: string; // keyPath\r\n  headers: Record<string, string>;\r\n  blob: Blob;\r\n  epoch: number;\r\n}\r\n\r\ninterface FetchAllBlocker {\r\n  mapID: string;\r\n  total: number;\r\n  count: number;\r\n  error: number;\r\n  cancel?: boolean;\r\n}\r\n\r\ninterface DBDict {\r\n  [name: string]: IDBDatabase;\r\n}\r\n\r\ninterface DBCountResult {\r\n  count: number;\r\n  size: number;\r\n  total?: number;\r\n  percent?: number;\r\n}\r\n\r\ndeclare const self: ServiceWorkerGlobalScope;\r\n\r\n// Allow string based method to be compatible with both Workbox types and simple strings\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport function Weiwudi_Internal(registerRoute: (capture: RegExp, handler: RouteHandlerCallback, method?: any) => any) {\r\n  \"use strict\";\r\n  const MERC_MAX = 20037508.342789244;\r\n  const dbCache: DBDict = {};\r\n  let fetchAllBlocker: FetchAllBlocker | undefined;\r\n\r\n  const extractTemplate = (template: string, z: number, x: number, y: number) => {\r\n    const result = template.replace('{z}', String(z))\r\n      .replace('{x}', String(x))\r\n      .replace('{y}', String(y))\r\n      .replace('{-y}', String(Math.pow(2, z) - y - 1));\r\n    return result;\r\n  };\r\n  const b64toBlob = (b64Data: string, contentType = '', sliceSize = 512) => {\r\n    const byteCharacters = atob(b64Data);\r\n    const byteArrays = [];\r\n\r\n    for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {\r\n      const slice = byteCharacters.slice(offset, offset + sliceSize);\r\n\r\n      const byteNumbers = new Array(slice.length);\r\n      for (let i = 0; i < slice.length; i++) {\r\n        byteNumbers[i] = slice.charCodeAt(i);\r\n      }\r\n\r\n      const byteArray = new Uint8Array(byteNumbers);\r\n      byteArrays.push(byteArray);\r\n    }\r\n\r\n    const blob = new Blob(byteArrays, { type: contentType });\r\n    return blob;\r\n  };\r\n  const getDB = async (dbname: string, table?: string, key?: string): Promise<IDBDatabase> => {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (dbCache[dbname]) resolve(dbCache[dbname]);\r\n        else {\r\n          const openDB = indexedDB.open(dbname);\r\n          openDB.onupgradeneeded = function (event) {\r\n            const db = (event.target as IDBOpenDBRequest).result;\r\n            if (table && key) db.createObjectStore(table, { keyPath: key });\r\n          };\r\n          openDB.onsuccess = function (event) {\r\n            const db = (event.target as IDBOpenDBRequest).result;\r\n            dbCache[dbname] = db;\r\n            resolve(db);\r\n          };\r\n          openDB.onerror = function (_error) {\r\n            reject(openDB.error);\r\n          };\r\n        }\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n    });\r\n  };\r\n  const deleteDB = async (dbname: string): Promise<void> => {\r\n    if (dbCache[dbname]) {\r\n      const db = dbCache[dbname];\r\n      db.close();\r\n      delete dbCache[dbname];\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        const deleteReq = indexedDB.deleteDatabase(dbname);\r\n\r\n        deleteReq.onsuccess = async (_event) => {\r\n          resolve();\r\n        };\r\n        deleteReq.onerror = function (error) {\r\n          reject(error);\r\n        };\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n    });\r\n  };\r\n  const cleanDB = async (db: IDBDatabase, table: string): Promise<void> => {\r\n    return new Promise((resolve, reject) => {\r\n      const tx = db.transaction([table], 'readwrite');\r\n      const store = tx.objectStore(table);\r\n      const clearReq = store.clear();\r\n      clearReq.onsuccess = function (_e) {\r\n      };\r\n      clearReq.onerror = function (e) {\r\n        reject(e);\r\n      };\r\n      tx.oncomplete = function (_e) {\r\n        resolve();\r\n      };\r\n      tx.onabort = function (e) {\r\n        reject(e);\r\n      };\r\n      tx.onerror = function (e) {\r\n        reject(e);\r\n      };\r\n    });\r\n  };\r\n  const countDB = async (db: IDBDatabase, table: string): Promise<DBCountResult> => {\r\n    return new Promise((resolve, reject) => {\r\n      const tx = db.transaction([table], 'readonly');\r\n      const store = tx.objectStore(table);\r\n      const cursorReq = store.openCursor();\r\n      let count = 0;\r\n      let size = 0;\r\n      cursorReq.onsuccess = function (_e) {\r\n        const cursor = cursorReq.result;\r\n        if (cursor) {\r\n          count++;\r\n          size = size + (cursor.value.blob.size as number);\r\n          cursor.continue();\r\n        }\r\n      };\r\n      cursorReq.onerror = function (e) {\r\n        reject(e);\r\n      };\r\n      tx.oncomplete = function (_e) {\r\n        resolve({\r\n          count: count,\r\n          size: size\r\n        });\r\n      };\r\n      tx.onabort = function (e) {\r\n        reject(e);\r\n      };\r\n      tx.onerror = function (e) {\r\n        reject(e);\r\n      };\r\n    });\r\n  };\r\n  const getItem = async (db: IDBDatabase, table: string, key: string, dry?: boolean): Promise<unknown> => {\r\n    return new Promise((resolve, reject) => {\r\n      const tx = db.transaction([table], 'readonly');\r\n      const store = tx.objectStore(table);\r\n      const getReq = dry ? store.getKey(key) : store.get(key);\r\n      getReq.onsuccess = function (_e) {\r\n      };\r\n      getReq.onerror = function (e) {\r\n        reject(e);\r\n      };\r\n      tx.oncomplete = function (_e) {\r\n        resolve(getReq.result);\r\n      };\r\n      tx.onabort = function (e) {\r\n        reject(e);\r\n      };\r\n      tx.onerror = function (e) {\r\n        reject(e);\r\n      };\r\n    });\r\n  };\r\n  const putItem = async (db: IDBDatabase, table: string, item: unknown): Promise<void> => {\r\n    return new Promise((resolve, reject) => {\r\n      const tx = db.transaction([table], 'readwrite');\r\n      const store = tx.objectStore(table);\r\n      const putReq = store.put(item);\r\n      putReq.onsuccess = function (_e) {\r\n      };\r\n      putReq.onerror = function (e) {\r\n        reject(e);\r\n      };\r\n      tx.oncomplete = function (_e) {\r\n        resolve();\r\n      };\r\n      tx.onabort = function (e) {\r\n        reject(e);\r\n      };\r\n      tx.onerror = function (e) {\r\n        reject(e);\r\n      };\r\n    });\r\n  };\r\n  const deleteItem = async (db: IDBDatabase, table: string, key: string): Promise<void> => {\r\n    return new Promise((resolve, reject) => {\r\n      const tx = db.transaction([table], 'readwrite');\r\n      const store = tx.objectStore(table);\r\n      const delReq = store.delete(key);\r\n      delReq.onsuccess = function (_e) {\r\n      };\r\n      delReq.onerror = function (e) {\r\n        reject(e);\r\n      };\r\n      tx.oncomplete = function (_e) {\r\n        resolve();\r\n      };\r\n      tx.onabort = function (e) {\r\n        reject(e);\r\n      };\r\n      tx.onerror = function (e) {\r\n        reject(e);\r\n      };\r\n    });\r\n  };\r\n  const getAllKeys = async (db: IDBDatabase, table: string): Promise<unknown[]> => {\r\n    return new Promise((resolve, reject) => {\r\n      const tx = db.transaction([table], 'readwrite');\r\n      const store = tx.objectStore(table);\r\n      const getReq = store.getAllKeys();\r\n      getReq.onsuccess = function (_e) {\r\n      };\r\n      getReq.onerror = function (e) {\r\n        reject(e);\r\n      };\r\n      tx.oncomplete = function (_e) {\r\n        resolve(getReq.result);\r\n      };\r\n      tx.onabort = function (e) {\r\n        reject(e);\r\n      };\r\n      tx.onerror = function (e) {\r\n        reject(e);\r\n      };\r\n    });\r\n  };\r\n  const handlerCb: RouteHandlerCallback = async ({ url, event }) => {\r\n    const fetchEvent = event instanceof FetchEvent ? event : undefined;\r\n    const client = fetchEvent && fetchEvent.clientId ? await self.clients.get(fetchEvent.clientId) : undefined;\r\n    const matched = url.pathname.match(/^\\/api\\/([\\w\\d]+)(?:\\/(.+))?$/);\r\n    if (matched) {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const query = [...url.searchParams.entries()].reduce((obj: any, e) => {\r\n        const values = url.searchParams.getAll(e[0]);\r\n        if (values.length === 1) obj[e[0]] = values[0];\r\n        else obj[e[0]] = values;\r\n        return obj;\r\n      }, {});\r\n      const apiName = matched[1];\r\n      const restPath = matched[2];\r\n      let res = await apiFunc(apiName, query, restPath, client);\r\n      if (res) {\r\n        if (!(res instanceof Response)) res = new Response(res);\r\n        return res;\r\n      }\r\n    }\r\n    return new Response('Not Found', { status: 404 });\r\n  };\r\n  const getImage = async (mapID: string, z: number, x: number, y: number, noOutput?: boolean) => {\r\n    let outExtent;\r\n    const db = await getDB('Weiwudi');\r\n    const setting = await getItem(db, 'mapSetting', mapID) as MapSetting;\r\n    if (!noOutput) {\r\n      if (!setting) return `Error: MapID \"${mapID}\" not found`;\r\n      if (z < (setting.minZoom || 0) || z > (setting.maxZoom || 0)) outExtent = 'zoom';\r\n      else {\r\n        const factor = Math.pow(2, (setting.maxZoom || 0) - z);\r\n        const minXatZ = Math.floor((setting.minX || 0) / factor);\r\n        const maxXatZ = Math.floor((setting.maxX || 0) / factor);\r\n        const minYatZ = Math.floor((setting.minY || 0) / factor);\r\n        const maxYatZ = Math.floor((setting.maxY || 0) / factor);\r\n        if (x < minXatZ || x > maxXatZ || y < minYatZ || y > maxYatZ) outExtent = 'extent';\r\n      }\r\n    }\r\n    let headers: Record<string, string> = {};\r\n    let blob: Blob | undefined;\r\n    let status = 200;\r\n    let statusText = 'OK';\r\n    if (outExtent) {\r\n      if (outExtent === 'zoom') {\r\n        status = 404;\r\n        statusText = 'Not Found';\r\n      } else {\r\n        headers = {\r\n          'content-type': 'image/png'\r\n        };\r\n        blob = b64toBlob('iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAAB3RJTUUH3QgIBToaSbAjlwAAABd0' +\r\n          'RVh0U29mdHdhcmUAR0xEUE5HIHZlciAzLjRxhaThAAAACHRwTkdHTEQzAAAAAEqAKR8AAAAEZ0FN' +\r\n          'QQAAsY8L/GEFAAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAAFRJREFUeNrtwQEBAAAAgJD+' +\r\n          'r+4ICgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' +\r\n          'AAAAAAAAAAAAABgBDwABHHIJwwAAAABJRU5ErkJggg==', headers['content-type']);\r\n      }\r\n    } else {\r\n      const cacheDB = await getDB(`Weiwudi_${mapID}`);\r\n      const cached = await getItem(cacheDB, 'tileCache', `${z}_${x}_${y}`, noOutput) as TileCacheItem;\r\n      const nowEpoch = new Date().getTime();\r\n      if (!cached || !cached.epoch || nowEpoch - cached.epoch > 86400000) {\r\n        // Handle setting.url being potentially undefined or array\r\n        let template = '';\r\n        if (setting.url instanceof Array) {\r\n          template = setting.url[Math.floor(Math.random() * setting.url.length)];\r\n        } else if (typeof setting.url === 'string') {\r\n          template = setting.url;\r\n        }\r\n\r\n        const url = extractTemplate(template, z, x, y);\r\n        try {\r\n          const resp = await fetch(url);\r\n          if (resp.ok) {\r\n            headers = {};\r\n            resp.headers.forEach((val, key) => { headers[key] = val; });\r\n            blob = await resp.blob();\r\n            await putItem(cacheDB, 'tileCache', {\r\n              'z_x_y': `${z}_${x}_${y}`,\r\n              headers: headers,\r\n              blob: blob,\r\n              epoch: nowEpoch\r\n            });\r\n          } else {\r\n            if (cached) {\r\n              headers = cached.headers;\r\n              blob = cached.blob;\r\n            } else {\r\n              status = resp.status;\r\n              statusText = resp.statusText;\r\n              headers = {};\r\n              resp.headers.forEach((val, key) => { headers[key] = val; });\r\n              blob = await resp.blob();\r\n            }\r\n            if (fetchAllBlocker) fetchAllBlocker.error++;\r\n          }\r\n        } catch (_e) {\r\n          if (cached) {\r\n            headers = cached.headers;\r\n            blob = cached.blob;\r\n          } else {\r\n            status = 404;\r\n            statusText = 'Not Found';\r\n          }\r\n          if (fetchAllBlocker) fetchAllBlocker.error++;\r\n        }\r\n      } else if (!noOutput) {\r\n        headers = cached.headers;\r\n        blob = cached.blob;\r\n      }\r\n    }\r\n    return noOutput ? undefined : new Response(blob, {\r\n      status,\r\n      statusText,\r\n      headers: new Headers(headers)\r\n    });\r\n  };\r\n  const fetchAll = async (client: Client, setting: MapSetting) => {\r\n    let processed = 0;\r\n    let percent = 0;\r\n    const db = await getDB(`Weiwudi_${setting.mapID}`);\r\n    const allKeys = await getAllKeys(db, 'tileCache');\r\n    try {\r\n      const allTasks = [];\r\n      const minZoom = setting.minZoom || 0;\r\n      const maxZoom = setting.maxZoom || 0;\r\n      for (let z = minZoom; z <= maxZoom; z++) {\r\n        const factor = Math.pow(2, maxZoom - z);\r\n        const maxXatZ = Math.floor((setting.maxX || 0) / factor);\r\n        const minXatZ = Math.floor((setting.minX || 0) / factor);\r\n        const maxYatZ = Math.floor((setting.maxY || 0) / factor);\r\n        const minYatZ = Math.floor((setting.minY || 0) / factor);\r\n        for (let x = minXatZ; x <= maxXatZ; x++) {\r\n          for (let y = minYatZ; y <= maxYatZ; y++) {\r\n            allTasks.push([z, x, y]);\r\n          }\r\n        }\r\n      }\r\n      if (allTasks.length != setting.totalTile) console.log('Number of tiles is different');\r\n      let subTasks = allTasks.splice(0, 5);\r\n      while (subTasks.length) {\r\n        //Alive check\r\n        const checkClient = await self.clients.get(client.id);\r\n        if (!checkClient) {\r\n          fetchAllBlocker = undefined;\r\n          return;\r\n        }\r\n        if (fetchAllBlocker && fetchAllBlocker.cancel) {\r\n          fetchAllBlocker = undefined;\r\n          client.postMessage({\r\n            type: 'canceled',\r\n            message: `Fetching tile of ${setting.mapID} is canceled`,\r\n            mapID: setting.mapID\r\n          });\r\n          return;\r\n        }\r\n        const promises = subTasks.map((task) => {\r\n          if (allKeys.indexOf(`${task[0]}_${task[1]}_${task[2]}`) >= 0) return;\r\n          return getImage(setting.mapID, task[0], task[1], task[2], true);\r\n        });\r\n        await Promise.all(promises);\r\n        processed += promises.length;\r\n        if (fetchAllBlocker) fetchAllBlocker.count = processed;\r\n        percent = Math.floor(processed * 100 / (setting.totalTile || 1));\r\n        client.postMessage({\r\n          type: 'proceed',\r\n          message: `Proceeding the tile fetching: ${setting.mapID} ${percent}% (${processed} / ${setting.totalTile})`,\r\n          percent,\r\n          processed,\r\n          error: fetchAllBlocker ? fetchAllBlocker.error : 0,\r\n          total: setting.totalTile,\r\n          mapID: setting.mapID\r\n        });\r\n        subTasks = allTasks.splice(0, 5);\r\n      }\r\n      const error = fetchAllBlocker ? fetchAllBlocker.error : 0;\r\n      fetchAllBlocker = undefined;\r\n      client.postMessage({\r\n        type: 'finish',\r\n        message: `Fetched all tiles of ${setting.mapID}${error ? ` with ${error} error cases` : ''}`,\r\n        total: setting.totalTile,\r\n        mapID: setting.mapID,\r\n        error\r\n      });\r\n    } catch (e) {\r\n      fetchAllBlocker = undefined;\r\n      client.postMessage({\r\n        type: 'stop',\r\n        message: `Fetching stopped: ${setting.mapID} ${processed} / ${setting.totalTile}`,\r\n        reason: e,\r\n        processed,\r\n        total: setting.totalTile,\r\n        mapID: setting.mapID\r\n      });\r\n    }\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  const apiFunc = async (apiName: string, query: any, restPath: string | undefined, client?: Client) => {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    let retVal: any;\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    const checkAttributes = (query: any, targets: string[]) => {\r\n      return targets.reduce((prev: string | undefined, target) => {\r\n        if (prev) return prev;\r\n        if (query[target] === undefined) return `Error: Attribute \"${target}\" is missing`;\r\n        return prev;\r\n      }, undefined);\r\n    };\r\n    try {\r\n      switch (apiName) {\r\n        case 'ping':\r\n          retVal = 'Implemented';\r\n          break;\r\n        case 'info':\r\n          retVal = checkAttributes(query, ['mapID']);\r\n          if (!retVal) {\r\n            const db = await getDB('Weiwudi', 'mapSetting', 'mapID');\r\n            const setting = await getItem(db, 'mapSetting', query.mapID);\r\n            if (!setting) retVal = `Error: MapID \"${query.mapID}\" not found`;\r\n            else {\r\n              retVal = new Response(JSON.stringify(setting), {\r\n                headers: new Headers({\r\n                  'content-type': 'application/json'\r\n                })\r\n              });\r\n            }\r\n          }\r\n          break;\r\n        case 'add': {\r\n          const db = await getDB('Weiwudi', 'mapSetting', 'mapID');\r\n          retVal = checkAttributes(query, ['mapID', 'type', 'url']);\r\n          if (!retVal) {\r\n            query.tileSize = parseInt(query.tileSize || 256);\r\n            switch (query.type) {\r\n              case 'xyz':\r\n                retVal = checkAttributes(query, ['width', 'height']);\r\n                if (!retVal) {\r\n                  query.width = parseInt(query.width);\r\n                  query.height = parseInt(query.height);\r\n                  const calcZoom = (v: number) => { return Math.ceil(Math.log(v / query.tileSize) / Math.log(2)) };\r\n                  query.maxZoom = Math.max(calcZoom(query.width), calcZoom(query.height));\r\n                  query.minZoom = query.minZoom ? parseInt(query.minZoom) : 0;\r\n                  query.minX = 0;\r\n                  query.minY = 0;\r\n                  query.maxX = Math.ceil(query.width / query.tileSize) - 1;\r\n                  query.maxY = Math.ceil(query.height / query.tileSize) - 1;\r\n                }\r\n                break;\r\n              case 'wmts':\r\n                if (!retVal) {\r\n                  const lng2MercX = (lng: number) => { return 6378137 * lng * Math.PI / 180 };\r\n                  const lat2MercY = (lat: number) => { return 6378137 * Math.log(Math.tan(Math.PI / 360 * (90 + lat))) };\r\n                  if (query.maxZoom) query.maxZoom = parseInt(query.maxZoom);\r\n                  if (query.minZoom) query.minZoom = parseInt(query.minZoom);\r\n                  if (query.maxLng && query.minLng && query.maxLat && query.minLat) {\r\n                    query.maxLng = parseFloat(query.maxLng);\r\n                    query.minLng = parseFloat(query.minLng);\r\n                    query.maxLat = parseFloat(query.maxLat);\r\n                    query.minLat = parseFloat(query.minLat);\r\n                    const maxMercX = lng2MercX(query.maxLng);\r\n                    const minMercX = lng2MercX(query.minLng);\r\n                    const maxMercY = lat2MercY(query.maxLat);\r\n                    const minMercY = lat2MercY(query.minLat);\r\n                    query.minX = Math.floor((MERC_MAX + minMercX) / (2 * MERC_MAX) * Math.pow(2, query.maxZoom));\r\n                    query.maxX = Math.floor((MERC_MAX + maxMercX) / (2 * MERC_MAX) * Math.pow(2, query.maxZoom));\r\n                    query.minY = Math.floor((MERC_MAX - maxMercY) / (2 * MERC_MAX) * Math.pow(2, query.maxZoom));\r\n                    query.maxY = Math.floor((MERC_MAX - minMercY) / (2 * MERC_MAX) * Math.pow(2, query.maxZoom));\r\n                  }\r\n                }\r\n                break;\r\n              default:\r\n                retVal = 'Error: Unknown \"type\" value';\r\n            }\r\n          }\r\n          if (!retVal) {\r\n            if (!checkAttributes(query, ['maxX', 'minX', 'maxY', 'minY', 'minZoom', 'maxZoom'])) {\r\n              query.totalTile = 0;\r\n              const calcTileCoord = (atMaxZoom: number, zoom: number) => { return Math.floor(atMaxZoom / Math.pow(2, query.maxZoom - zoom)) };\r\n              for (let z = query.minZoom; z <= query.maxZoom; z++) {\r\n                const minX = calcTileCoord(query.minX, z);\r\n                const minY = calcTileCoord(query.minY, z);\r\n                const maxX = calcTileCoord(query.maxX, z);\r\n                const maxY = calcTileCoord(query.maxY, z);\r\n                query.totalTile += (maxX - minX + 1) * (maxY - minY + 1);\r\n              }\r\n            }\r\n            await putItem(db, 'mapSetting', query);\r\n            await getDB(`Weiwudi_${query.mapID}`, 'tileCache', 'z_x_y');\r\n            retVal = new Response(JSON.stringify(query), {\r\n              headers: new Headers({\r\n                'content-type': 'application/json'\r\n              })\r\n            });\r\n          }\r\n          break;\r\n        }\r\n        case 'clean':\r\n          retVal = checkAttributes(query, ['mapID']);\r\n          if (fetchAllBlocker && fetchAllBlocker.mapID == query.mapID) {\r\n            retVal = `Error: ${query.mapID} is under fetching process. Please cancel it first`;\r\n          } else if (!retVal) {\r\n            const cacheDB = await getDB(`Weiwudi_${query.mapID}`);\r\n            await cleanDB(cacheDB, 'tileCache');\r\n            retVal = `Cleaned: ${query.mapID}`;\r\n          }\r\n          break;\r\n        case 'delete':\r\n          retVal = checkAttributes(query, ['mapID']);\r\n          if (fetchAllBlocker && fetchAllBlocker.mapID == query.mapID) {\r\n            retVal = `Error: ${query.mapID} is under fetching process. Please cancel it first`;\r\n          } else if (!retVal) {\r\n            await deleteDB(`Weiwudi_${query.mapID}`);\r\n            const db = await getDB('Weiwudi');\r\n            await deleteItem(db, 'mapSetting', query.mapID);\r\n            retVal = `Deleted: ${query.mapID}`;\r\n          }\r\n          break;\r\n        case 'cancel':\r\n          retVal = checkAttributes(query, ['mapID']);\r\n          if (fetchAllBlocker && fetchAllBlocker.mapID == query.mapID) {\r\n            fetchAllBlocker.cancel = true;\r\n            retVal = `Fetching process of ${fetchAllBlocker.mapID} is canceled`;\r\n          } else {\r\n            retVal = `Error: There are no fetching process of ${query.mapID}`;\r\n          }\r\n          break;\r\n        case 'stats':\r\n          retVal = checkAttributes(query, ['mapID']);\r\n          if (!retVal) {\r\n            const db = await getDB('Weiwudi');\r\n            const setting = await getItem(db, 'mapSetting', query.mapID) as MapSetting;\r\n            if (!setting) retVal = `Error: MapID \"${query.mapID}\" not found`;\r\n            else {\r\n              const cacheDB = await getDB(`Weiwudi_${query.mapID}`);\r\n              const ret = await countDB(cacheDB, 'tileCache');\r\n              if (setting.totalTile) {\r\n                ret.total = setting.totalTile;\r\n                ret.percent = Math.floor(ret.count / ret.total! * 100);\r\n              }\r\n              retVal = new Response(JSON.stringify(ret), {\r\n                headers: new Headers({\r\n                  'content-type': 'application/json'\r\n                })\r\n              });\r\n            }\r\n          }\r\n          break;\r\n        case 'cache': {\r\n          const matched = restPath?.match(/^([^/]+)\\/(\\d+)\\/(\\d+)\\/(\\d+)$/);\r\n          if (matched) {\r\n            retVal = await getImage(matched[1], parseInt(matched[2]), parseInt(matched[3]), parseInt(matched[4]));\r\n          } else {\r\n            retVal = 'Error: \"cache\" api needs mapID, zoom, x, y settings';\r\n          }\r\n          break;\r\n        }\r\n        case 'fetchAll':\r\n          retVal = checkAttributes(query, ['mapID']);\r\n          if (!retVal && client) {\r\n            const db = await getDB('Weiwudi');\r\n            const setting = await getItem(db, 'mapSetting', query.mapID) as MapSetting;\r\n            if (!setting) retVal = `Error: MapID \"${query.mapID}\" not found`;\r\n            else if (!setting.totalTile) retVal = `Error: Map \"${query.mapID}\" cannot fetch all tiles`;\r\n            else if (fetchAllBlocker) {\r\n              retVal = `Error: Another fetching process is running: \"${fetchAllBlocker.mapID}\" (${fetchAllBlocker.count} / ${fetchAllBlocker.total})`;\r\n            } else {\r\n              setTimeout(() => {\r\n                fetchAllBlocker = {\r\n                  mapID: query.mapID,\r\n                  total: setting.totalTile || 0,\r\n                  count: 0,\r\n                  error: 0\r\n                };\r\n                fetchAll(client, setting);\r\n              }, 1);\r\n              retVal = `Fetching task start: ${query.mapID}`;\r\n            }\r\n          }\r\n          break;\r\n        default:\r\n          retVal = `Error: API ${apiName} not found`;\r\n      }\r\n    } catch (e) {\r\n      retVal = `Error: ${e}`;\r\n    }\r\n\r\n    if (retVal) return retVal;\r\n  };\r\n\r\n  registerRoute(/^https?:\\/\\/weiwudi.example.com/, handlerCb, 'GET');\r\n}","import {registerRoute} from \"workbox-routing\";\r\nimport {Weiwudi_Internal} from \"./weiwudi_gw_logic\";\r\n\r\nWeiwudi_Internal(registerRoute);"],"names":["fallback","code","args","msg","messageGenerator","WorkboxError","errorCode","details","message","defaultMethod","normalizeHandler","handler","Route","match","method","RegExpRoute","regExp","url","result","Router","event","request","responsePromise","payload","requestPromises","entry","sameOrigin","params","route","err","catchHandler","catchErr","routes","matchResult","routeIndex","defaultRouter","getOrCreateDefaultRouter","registerRoute","capture","captureUrl","matchCallback","Weiwudi_Internal","MERC_MAX","dbCache","fetchAllBlocker","extractTemplate","template","z","x","y","b64toBlob","b64Data","contentType","sliceSize","byteCharacters","byteArrays","offset","slice","byteNumbers","i","byteArray","getDB","dbname","table","key","resolve","reject","openDB","db","_error","e","deleteDB","deleteReq","_event","error","cleanDB","tx","clearReq","_e","countDB","cursorReq","count","size","cursor","getItem","dry","store","getReq","putItem","item","putReq","deleteItem","delReq","getAllKeys","handlerCb","fetchEvent","client","matched","query","obj","values","apiName","restPath","res","apiFunc","getImage","mapID","noOutput","outExtent","setting","factor","minXatZ","maxXatZ","minYatZ","maxYatZ","headers","blob","status","statusText","cacheDB","cached","nowEpoch","resp","val","fetchAll","processed","percent","allKeys","allTasks","minZoom","maxZoom","subTasks","promises","task","retVal","checkAttributes","targets","prev","target","calcZoom","v","lng2MercX","lng","lat2MercY","lat","maxMercX","minMercX","maxMercY","minMercY","calcTileCoord","atMaxZoom","zoom","minX","minY","maxX","maxY","ret"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10]}