{"version":3,"file":"weiwudi.es.js","sources":["../src/weiwudi.ts"],"sourcesContent":["\"use strict\";\r\n\r\nconst BASEURL = 'https://weiwudi.example.com/api/';\r\nlet swChecking: Promise<boolean> | undefined;\r\nlet swChecked: boolean | undefined;\r\n\r\n// Polyfill removed as target is ES2020\r\n\r\nclass EventTarget {\r\n    listeners: Record<string, ((...args: unknown[]) => void)[]>;\r\n\r\n    constructor() {\r\n        this.listeners = {};\r\n    }\r\n\r\n    addEventListener(type: string, callback: (...args: unknown[]) => void) {\r\n        if (!(type in this.listeners)) {\r\n            this.listeners[type] = [];\r\n        }\r\n        this.listeners[type].push(callback);\r\n    }\r\n\r\n    removeEventListener(type: string, callback: (...args: unknown[]) => void) {\r\n        if (!(type in this.listeners)) {\r\n            return;\r\n        }\r\n        const stack = this.listeners[type];\r\n        for (let i = 0, l = stack.length; i < l; i++) {\r\n            if (stack[i] === callback) {\r\n                stack.splice(i, 1);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    dispatchEvent(event: Event | CustomEvent) {\r\n        if (!(event.type in this.listeners)) {\r\n            return true;\r\n        }\r\n        const stack = this.listeners[event.type].slice();\r\n\r\n        for (let i = 0, l = stack.length; i < l; i++) {\r\n            stack[i].call(this, event);\r\n        }\r\n        return !event.defaultPrevented;\r\n    }\r\n}\r\n\r\nexport interface WeiwudiOptions {\r\n    type?: string;\r\n    url?: string;\r\n    width?: number;\r\n    height?: number;\r\n    tileSize?: number;\r\n    minZoom?: number;\r\n    maxZoom?: number;\r\n    maxLng?: number;\r\n    maxLat?: number;\r\n    minLng?: number;\r\n    minLat?: number;\r\n    [key: string]: unknown;\r\n}\r\n\r\nexport interface WeiwudiInternalOps {\r\n    // Placeholder for future strict typing of internal operations\r\n    [key: string]: unknown;\r\n}\r\n\r\nexport default class Weiwudi extends EventTarget {\r\n    mapID?: string;\r\n    url?: string;\r\n    listener: (e: MessageEvent) => void;\r\n\r\n    static async registerSW(sw: string | URL, swOptions?: RegistrationOptions) {\r\n        if ('serviceWorker' in navigator) {\r\n            try {\r\n                const reg = await navigator.serviceWorker.register(sw, swOptions);\r\n                //console.log('Service Worker Registered');\r\n\r\n                // A wild service worker has appeared in reg.installing and maybe in waiting!\r\n                const newWorker = reg.installing;\r\n                const waitingWoker = reg.waiting;\r\n\r\n                if (newWorker) {\r\n                    if (newWorker.state === 'activated' && !waitingWoker) {\r\n                        // reload to avoid skipWaiting and clients.claim()\r\n                        window.location.reload();\r\n                    }\r\n                    newWorker.addEventListener('statechange', (_e) => {\r\n                        // newWorker.state has changed\r\n                        if (newWorker.state === 'activated' && !waitingWoker) {\r\n                            // reload to avoid skipWaiting and clients.claim()\r\n                            window.location.reload();\r\n                        }\r\n                    });\r\n                }\r\n                reg.onupdatefound = () => {\r\n                    //console.log('Found Service Worker update');\r\n                    reg.update();\r\n                };\r\n\r\n                await Weiwudi.swCheck();\r\n\r\n                return reg;\r\n            } catch (e) {\r\n                throw (`Error: Service worker registration failed with ${e}`);\r\n            }\r\n        } else {\r\n            throw ('Error: Service worker is not supported');\r\n        }\r\n    }\r\n\r\n    static async swCheck() {\r\n        if (swChecked !== undefined) return swChecked;\r\n        if (swChecking === undefined) swChecking = new Promise((res, _rej) => {\r\n            // Removing async from executor and handling promise explicitly if needed, \r\n            // but here the code was wrapping await in a new Promise which is antipattern.\r\n            // We can just rely on correct async flow or keep simpler.\r\n            // Given logic:\r\n            fetch(`${BASEURL}ping`)\r\n                .then(r => {\r\n                    swChecked = !!r;\r\n                    res(swChecked);\r\n                })\r\n                .catch(_e => {\r\n                    swChecked = false;\r\n                    res(swChecked);\r\n                });\r\n        });\r\n        return swChecking;\r\n    }\r\n\r\n    static async registerMap(mapID: string, options: WeiwudiOptions) {\r\n        const swCheck = await Weiwudi.swCheck();\r\n        if (!swCheck) throw ('Weiwudi service worker is not implemented.');\r\n        let text;\r\n        const p = ['type', 'url', 'width', 'height', 'tileSize', 'minZoom', 'maxZoom', 'maxLng', 'maxLat', 'minLng', 'minLat'].reduce((p, key) => {\r\n            if (typeof options[key] !== 'undefined') {\r\n                if (options[key] instanceof Array) {\r\n                    options[key].map((val: string) => {\r\n                        p.append(key, val);\r\n                    });\r\n                } else {\r\n                    p.append(key, String(options[key]));\r\n                }\r\n            }\r\n            return p;\r\n        }, new URLSearchParams());\r\n        p.append('mapID', mapID);\r\n        const url = new URL(`${BASEURL}add`);\r\n        url.search = p.toString(); // URLSearchParams to string\r\n        const res = await fetch(url.href);\r\n        text = await res.text();\r\n        if (text.match(/^Error: /)) {\r\n            throw (text);\r\n        }\r\n        return new Weiwudi(mapID, JSON.parse(text));\r\n    }\r\n\r\n    static async retrieveMap(mapID: string) {\r\n        const swCheck = await Weiwudi.swCheck();\r\n        if (!swCheck) throw ('Weiwudi service worker is not implemented.');\r\n        let text;\r\n        const res = await fetch(`${BASEURL}info?mapID=${mapID}`);\r\n        text = await res.text();\r\n        if (text.match(/^Error: /)) {\r\n            throw (text);\r\n        }\r\n        console.log(text);\r\n        return new Weiwudi(mapID, JSON.parse(text));\r\n    }\r\n\r\n    static async removeMap(mapID: string) {\r\n        const swCheck = await Weiwudi.swCheck();\r\n        if (!swCheck) throw ('Weiwudi service worker is not implemented.');\r\n        let text;\r\n        const res = await fetch(`${BASEURL}delete?mapID=${mapID}`);\r\n        text = await res.text();\r\n        if (text.match(/^Error: /)) {\r\n            throw (text);\r\n        }\r\n    }\r\n\r\n    constructor(mapID: string, attrs?: WeiwudiOptions) {\r\n        super();\r\n        if (!mapID) throw ('MapID is necessary.');\r\n        this.mapID = mapID;\r\n        if (attrs) Object.assign(this, attrs);\r\n        this.url = `${BASEURL}cache/${mapID}/{z}/{x}/{y}`;\r\n        this.listener = (e: MessageEvent) => {\r\n            const eventMapID = e.data.mapID;\r\n            if (eventMapID !== mapID) return;\r\n            this.dispatchEvent(new CustomEvent(e.data.type, { detail: e.data }));\r\n        };\r\n        navigator.serviceWorker.addEventListener('message', this.listener);\r\n    }\r\n\r\n    release() {\r\n        navigator.serviceWorker.removeEventListener('message', this.listener);\r\n        delete this.mapID;\r\n    }\r\n\r\n    checkAspect() {\r\n        if (!this.mapID) throw ('This instance is already released.');\r\n    }\r\n\r\n    async stats() {\r\n        let text;\r\n        this.checkAspect();\r\n        const res = await fetch(`${BASEURL}stats?mapID=${this.mapID}`);\r\n        text = await res.text();\r\n        if (typeof text === 'string' && text.match(/^Error: /)) {\r\n            throw (text);\r\n        }\r\n        return JSON.parse(text);\r\n    }\r\n\r\n    async clean() {\r\n        let text;\r\n        this.checkAspect();\r\n        const res = await fetch(`${BASEURL}clean?mapID=${this.mapID}`);\r\n        text = await res.text();\r\n        if (text.match(/^Error: /)) {\r\n            throw (text);\r\n        }\r\n    }\r\n\r\n    async fetchAll() {\r\n        let text;\r\n        this.checkAspect();\r\n        const res = await fetch(`${BASEURL}fetchAll?mapID=${this.mapID}`);\r\n        text = await res.text();\r\n        if (text.match(/^Error: /)) {\r\n            throw (text);\r\n        }\r\n    }\r\n\r\n    async remove() {\r\n        this.checkAspect();\r\n        if (this.mapID) await Weiwudi.removeMap(this.mapID);\r\n        this.release();\r\n    }\r\n\r\n    async cancel() {\r\n        let text;\r\n        this.checkAspect();\r\n        const res = await fetch(`${BASEURL}cancel?mapID=${this.mapID}`);\r\n        text = await res.text();\r\n        if (text.match(/^Error: /)) {\r\n            throw (text);\r\n        }\r\n    }\r\n}"],"names":["BASEURL","swChecking","swChecked","EventTarget","type","callback","stack","i","l","event","Weiwudi","sw","swOptions","reg","newWorker","waitingWoker","_e","e","res","_rej","r","mapID","options","text","p","key","val","url","attrs"],"mappings":"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"}