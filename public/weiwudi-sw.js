(function(B){typeof define=="function"&&define.amd?define(B):B()})((function(){"use strict";try{self["workbox:core:7.3.0"]&&_()}catch{}const U=(A,...a)=>{let f=A;return a.length>0&&(f+=` :: ${JSON.stringify(a)}`),f};class P extends Error{constructor(a,f){const c=U(a,f);super(c),this.name=a,this.details=f}}try{self["workbox:routing:7.3.0"]&&_()}catch{}const Y="GET",L=A=>A&&typeof A=="object"?A:{handle:A};class S{constructor(a,f,c=Y){this.handler=L(f),this.match=a,this.method=c}setCatchHandler(a){this.catchHandler=L(a)}}class W extends S{constructor(a,f,c){const I=({url:b})=>{const p=a.exec(b.href);if(p&&!(b.origin!==location.origin&&p.index!==0))return p.slice(1)};super(I,f,c)}}class N{constructor(){this._routes=new Map,this._defaultHandlerMap=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",(a=>{const{request:f}=a,c=this.handleRequest({request:f,event:a});c&&a.respondWith(c)}))}addCacheListener(){self.addEventListener("message",(a=>{if(a.data&&a.data.type==="CACHE_URLS"){const{payload:f}=a.data,c=Promise.all(f.urlsToCache.map(I=>{typeof I=="string"&&(I=[I]);const b=new Request(...I);return this.handleRequest({request:b,event:a})}));a.waitUntil(c),a.ports&&a.ports[0]&&c.then(()=>a.ports[0].postMessage(!0))}}))}handleRequest({request:a,event:f}){const c=new URL(a.url,location.href);if(!c.protocol.startsWith("http"))return;const I=c.origin===location.origin,{params:b,route:p}=this.findMatchingRoute({event:f,request:a,sameOrigin:I,url:c});let w=p&&p.handler;const D=a.method;if(!w&&this._defaultHandlerMap.has(D)&&(w=this._defaultHandlerMap.get(D)),!w)return;let R;try{R=w.handle({url:c,request:a,event:f,params:b})}catch(E){R=Promise.reject(E)}const M=p&&p.catchHandler;return R instanceof Promise&&(this._catchHandler||M)&&(R=R.catch(async E=>{if(M)try{return await M.handle({url:c,request:a,event:f,params:b})}catch(k){k instanceof Error&&(E=k)}if(this._catchHandler)return this._catchHandler.handle({url:c,request:a,event:f});throw E})),R}findMatchingRoute({url:a,sameOrigin:f,request:c,event:I}){const b=this._routes.get(c.method)||[];for(const p of b){let w;const D=p.match({url:a,sameOrigin:f,request:c,event:I});if(D)return w=D,(Array.isArray(w)&&w.length===0||D.constructor===Object&&Object.keys(D).length===0||typeof D=="boolean")&&(w=void 0),{route:p,params:w}}return{}}setDefaultHandler(a,f=Y){this._defaultHandlerMap.set(f,L(a))}setCatchHandler(a){this._catchHandler=L(a)}registerRoute(a){this._routes.has(a.method)||this._routes.set(a.method,[]),this._routes.get(a.method).push(a)}unregisterRoute(a){if(!this._routes.has(a.method))throw new P("unregister-route-but-not-found-with-method",{method:a.method});const f=this._routes.get(a.method).indexOf(a);if(f>-1)this._routes.get(a.method).splice(f,1);else throw new P("unregister-route-route-not-registered")}}let H;const O=()=>(H||(H=new N,H.addFetchListener(),H.addCacheListener()),H);function z(A,a,f){let c;if(typeof A=="string"){const b=new URL(A,location.href),p=({url:w})=>w.href===b.href;c=new S(p,a,f)}else if(A instanceof RegExp)c=new W(A,a,f);else if(typeof A=="function")c=new S(A,a,f);else if(A instanceof S)c=A;else throw new P("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});return O().registerRoute(c),c}function J(A){const a=20037508342789244e-9,f={};let c;const I=(m,t,h,r)=>m.replace("{z}",t).replace("{x}",h).replace("{y}",r).replace("{-y}",Math.pow(2,t)-r-1),b=(m,t="",h=512)=>{const r=atob(m),e=[];for(let s=0;s<r.length;s+=h){const o=r.slice(s,s+h),n=new Array(o.length);for(let d=0;d<o.length;d++)n[d]=o.charCodeAt(d);const i=new Uint8Array(n);e.push(i)}return new Blob(e,{type:t})},p=async(m,t,h)=>new Promise((r,e)=>{try{if(f[m])r(f[m]);else{const l=indexedDB.open(m);l.onupgradeneeded=function(s){s.target.result.createObjectStore(t,{keyPath:h})},l.onsuccess=function(s){const o=s.target.result;f[m]=o,r(o)},l.onerror=function(s){e(s)}}}catch(l){e(l)}}),w=async m=>(f[m]&&(f[m].close(),delete f[m]),new Promise((t,h)=>{try{const r=indexedDB.deleteDatabase(m);r.onsuccess=async e=>{t()},r.onerror=function(e){h(e)}}catch(r){h(r)}})),D=async(m,t)=>new Promise((h,r)=>{const e=m.transaction([t],"readwrite"),s=e.objectStore(t).clear();s.onsuccess=function(o){},s.onerror=function(o){r(o)},e.oncomplete=function(o){h()},e.onabort=function(o){r(o)},e.onerror=function(o){r(o)}}),R=async(m,t)=>new Promise((h,r)=>{const e=m.transaction([t],"readonly"),s=e.objectStore(t).openCursor();let o=0,n=0;s.onsuccess=function(i){const d=s.result;d&&(o++,n=n+d.value.blob.size,d.continue())},s.onerror=function(i){r(i)},e.oncomplete=function(i){h({count:o,size:n})},e.onabort=function(i){r(i)},e.onerror=function(i){r(i)}}),M=async(m,t,h,r)=>new Promise((e,l)=>{const s=m.transaction([t],"readonly"),o=s.objectStore(t),n=r?o.getKey(h):o.get(h);n.onsuccess=function(i){},n.onerror=function(i){l(i)},s.oncomplete=function(i){e(n.result)},s.onabort=function(i){l(i)},s.onerror=function(i){l(i)}}),E=async(m,t,h)=>new Promise((r,e)=>{const l=m.transaction([t],"readwrite"),o=l.objectStore(t).put(h);o.onsuccess=function(n){},o.onerror=function(n){e(n)},l.oncomplete=function(n){r()},l.onabort=function(n){e(n)},l.onerror=function(n){e(n)}}),k=async(m,t,h)=>new Promise((r,e)=>{const l=m.transaction([t],"readwrite"),o=l.objectStore(t).delete(h);o.onsuccess=function(n){},o.onerror=function(n){e(n)},l.oncomplete=function(n){r()},l.onabort=function(n){e(n)},l.onerror=function(n){e(n)}}),K=async(m,t)=>new Promise((h,r)=>{const e=m.transaction([t],"readwrite"),s=e.objectStore(t).getAllKeys();s.onsuccess=function(o){},s.onerror=function(o){r(o)},e.oncomplete=function(o){h(s.result)},e.onabort=function(o){r(o)},e.onerror=function(o){r(o)}}),Q=async({url:m,request:t,event:h,_params:r})=>{const e=h.clientId?await self.clients.get(h.clientId):void 0,l=m.pathname.match(/^\/api\/([\w\d]+)(?:\/(.+))?$/);if(l){const s=[...m.searchParams.entries()].reduce((d,u)=>{const x=m.searchParams.getAll(u[0]);return x.length===1?d[u[0]]=x[0]:d[u[0]]=x,d},{}),o=l[1],n=l[2];let i=await V(o,s,n,e);if(i)return i instanceof Response||(i=new Response(i)),i}},F=async(m,t,h,r,e)=>{let l;const s=await p("Weiwudi"),o=await M(s,"mapSetting",m);if(!e){if(!o)return`Error: MapID "${m}" not found`;if(t<o.minZoom||t>o.maxZoom)l="zoom";else{const x=Math.floor(o.minX/Math.pow(2,o.maxZoom-t)),g=Math.floor(o.maxX/Math.pow(2,o.maxZoom-t)),$=Math.floor(o.minY/Math.pow(2,o.maxZoom-t)),T=Math.floor(o.maxY/Math.pow(2,o.maxZoom-t));(h<x||h>g||r<$||r>T)&&(l="extent")}}let n={},i,d=200,u="OK";if(l)l==="zoom"?(d=404,u="Not Found"):(n={"content-type":"image/png"},i=b("iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAAB3RJTUUH3QgIBToaSbAjlwAAABd0RVh0U29mdHdhcmUAR0xEUE5HIHZlciAzLjRxhaThAAAACHRwTkdHTEQzAAAAAEqAKR8AAAAEZ0FNQQAAsY8L/GEFAAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAAFRJREFUeNrtwQEBAAAAgJD+r+4ICgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgBDwABHHIJwwAAAABJRU5ErkJggg==",n["content-type"]));else{const x=await p(`Weiwudi_${m}`),g=await M(x,"tileCache",`${t}_${h}_${r}`,e),$=new Date().getTime();if(!g||!g.epoch||$-g.epoch>864e5){const T=o.url instanceof Array?o.url[Math.floor(Math.random()*o.url.length)]:o.url,j=I(T,t,h,r);try{const Z=await fetch(j);Z.ok?(n=[...Z.headers.entries()].reduce((X,C)=>({...X,[C[0]]:C[1]}),{}),i=await Z.blob(),await E(x,"tileCache",{z_x_y:`${t}_${h}_${r}`,headers:n,blob:i,epoch:$})):(g?(n=g.headers,i=g.blob):(d=Z.status,u=Z.statusText,n=[...Z.headers.entries()].reduce((X,C)=>({...X,[C[0]]:C[1]}),{}),i=await Z.blob()),c&&c.error++)}catch{g?(n=g.headers,i=g.blob):(d=404,u="Not Found"),c&&c.error++}}else e||(n=g.headers,i=g.blob)}return e?void 0:new Response(i,{status:d,statusText:u,headers:new Headers(n)})},G=async(m,t)=>{let h=0,r=0;const e=await p(`Weiwudi_${t.mapID}`),l=await K(e,"tileCache");try{const s=[];for(let i=t.minZoom;i<=t.maxZoom;i++){const d=Math.floor(t.maxX/Math.pow(2,t.maxZoom-i)),u=Math.floor(t.minX/Math.pow(2,t.maxZoom-i)),x=Math.floor(t.maxY/Math.pow(2,t.maxZoom-i)),g=Math.floor(t.minY/Math.pow(2,t.maxZoom-i));for(let $=u;$<=d;$++)for(let T=g;T<=x;T++)s.push([i,$,T])}s.length!=t.totalTile&&console.log("Number of tiles is different");let o=s.splice(0,5);for(;o.length;){if(!await self.clients.get(m.id)){c=void 0;return}if(c.cancel){c=void 0,m.postMessage({type:"canceled",message:`Fetching tile of ${t.mapID} is canceled`,mapID:t.mapID});return}const d=o.map(u=>{if(!(l.indexOf(`${u[0]}_${u[1]}_${u[2]}`)>=0))return F(t.mapID,u[0],u[1],u[2],!0)});await Promise.all(d),h+=d.length,c.count=h,r=Math.floor(h*100/t.totalTile),m.postMessage({type:"proceed",message:`Proceeding the tile fetching: ${t.mapID} ${r}% (${h} / ${t.totalTile})`,percent:r,processed:h,error:c.error,total:t.totalTile,mapID:t.mapID}),o=s.splice(0,5)}const n=c.error;c=void 0,m.postMessage({type:"finish",message:`Fetched all tiles of ${t.mapID}${n?` with ${n} error cases`:""}`,total:t.totalTile,mapID:t.mapID,error:n})}catch(s){c=void 0,m.postMessage({type:"stop",message:`Fetching stopped: ${t.mapID} ${h} / ${t.totalTile}`,reason:s,processed:h,total:t.totalTile,mapID:t.mapID})}},V=async(m,t,h,r)=>{let e;const l=(s,o)=>o.reduce((n,i)=>n||(s[i]===void 0?`Error: Attribute "${i}" is missing`:n),void 0);try{switch(m){case"ping":e="Implemented";break;case"info":if(e=l(t,["mapID"]),!e){const s=await p("Weiwudi","mapSetting","mapID"),o=await M(s,"mapSetting",t.mapID);o?e=new Response(JSON.stringify(o),{headers:new Headers({"content-type":"application/json"})}):e=`Error: MapID "${t.mapID}" not found`}break;case"add":{const s=await p("Weiwudi","mapSetting","mapID");if(e=l(t,["mapID","type","url"]),!e)switch(t.tileSize=parseInt(t.tileSize||256),t.type){case"xyz":if(e=l(t,["width","height"]),!e){t.width=parseInt(t.width),t.height=parseInt(t.height);const o=n=>Math.ceil(Math.log(n/t.tileSize)/Math.log(2));t.maxZoom=Math.max(o(t.width),o(t.height)),t.minZoom=t.minZoom?parseInt(t.minZoom):0,t.minX=0,t.minY=0,t.maxX=Math.ceil(t.width/t.tileSize)-1,t.maxY=Math.ceil(t.height/t.tileSize)-1}break;case"wmts":if(!e){const o=i=>6378137*i*Math.PI/180,n=i=>6378137*Math.log(Math.tan(Math.PI/360*(90+i)));if(t.maxZoom&&(t.maxZoom=parseInt(t.maxZoom)),t.minZoom&&(t.minZoom=parseInt(t.minZoom)),t.maxLng&&t.minLng&&t.maxLat&&t.minLat){t.maxLng=parseFloat(t.maxLng),t.minLng=parseFloat(t.minLng),t.maxLat=parseFloat(t.maxLat),t.minLat=parseFloat(t.minLat);const i=o(t.maxLng),d=o(t.minLng),u=n(t.maxLat),x=n(t.minLat);t.minX=Math.floor((a+d)/(2*a)*Math.pow(2,t.maxZoom)),t.maxX=Math.floor((a+i)/(2*a)*Math.pow(2,t.maxZoom)),t.minY=Math.floor((a-u)/(2*a)*Math.pow(2,t.maxZoom)),t.maxY=Math.floor((a-x)/(2*a)*Math.pow(2,t.maxZoom))}}break;default:e='Error: Unknown "type" value'}if(!e){if(!l(t,["maxX","minX","maxY","minY","minZoom","maxZoom"])){t.totalTile=0;const o=(n,i)=>Math.floor(n/Math.pow(2,t.maxZoom-i));for(let n=t.minZoom;n<=t.maxZoom;n++){const i=o(t.minX,n),d=o(t.minY,n),u=o(t.maxX,n),x=o(t.maxY,n);t.totalTile+=(u-i+1)*(x-d+1)}}await E(s,"mapSetting",t),await p(`Weiwudi_${t.mapID}`,"tileCache","z_x_y"),e=new Response(JSON.stringify(t),{headers:new Headers({"content-type":"application/json"})})}break}case"clean":if(e=l(t,["mapID"]),c&&c.mapID==t.mapID)e=`Error: ${t.mapID} is under fetching process. Please cancel it first`;else if(!e){const s=await p(`Weiwudi_${t.mapID}`);await D(s,"tileCache"),e=`Cleaned: ${t.mapID}`}break;case"delete":if(e=l(t,["mapID"]),c&&c.mapID==t.mapID)e=`Error: ${t.mapID} is under fetching process. Please cancel it first`;else if(!e){await w(`Weiwudi_${t.mapID}`);const s=await p("Weiwudi");await k(s,"mapSetting",t.mapID),e=`Deleted: ${t.mapID}`}break;case"cancel":e=l(t,["mapID"]),c&&c.mapID==t.mapID?(c.cancel=!0,e=`Fetching process of ${c.mapID} is canceled`):e=`Error: There are no fetching process of ${t.mapID}`;break;case"stats":if(e=l(t,["mapID"]),!e){const s=await p("Weiwudi"),o=await M(s,"mapSetting",t.mapID);if(!o)e=`Error: MapID "${t.mapID}" not found`;else{const n=await p(`Weiwudi_${t.mapID}`),i=await R(n,"tileCache");o.totalTile&&(i.total=o.totalTile,i.percent=Math.floor(i.count/i.total*100)),e=new Response(JSON.stringify(i),{headers:new Headers({"content-type":"application/json"})})}}break;case"cache":{const s=h.match(/^([^/]+)\/(\d+)\/(\d+)\/(\d+)$/);s?e=await F(s[1],parseInt(s[2]),parseInt(s[3]),parseInt(s[4])):e='Error: "cache" api needs mapID, zoom, x, y settings';break}case"fetchAll":if(e=l(t,["mapID"]),!e){const s=await p("Weiwudi"),o=await M(s,"mapSetting",t.mapID);o?o.totalTile?c?e=`Error: Another fetching process is running: "${c.mapID}" (${c.count} / ${c.total})`:(setTimeout(()=>{c={mapID:t.mapID,total:o.totalTile,count:0,error:0},G(r,o)},1),e=`Fetching task start: ${t.mapID}`):e=`Error: Map "${t.mapID}" cannot fetch all tiles`:e=`Error: MapID "${t.mapID}" not found`}break;default:e=`Error: API ${m} not found`}}catch(s){e=`Error: ${s}`}if(e)return e};A(/^https?:\/\/weiwudi.example.com/,Q,"GET")}J(z)}));
//# sourceMappingURL=weiwudi-sw.umd.js.map
